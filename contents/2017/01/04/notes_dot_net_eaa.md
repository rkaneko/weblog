.NET EAAを読んで考えたこと
===

# 第3部 サポートアーキテクチャ

## 第8章 ドメインモデルの紹介

- すべては振る舞いのために

ドメインモデルの目的は,アプリケーションで扱われる基本的なビジネスコンセプトをできるだけ忠実に表現することにある.

ドメインモデルに課される制約の目的は,クラスを基本的なビジネスコンセプトと完全に一致させ,常に整合性を確保することにある.

このために,データよりも振る舞いに重点を置いた設計にする必要がある.

- DDDはいつでも誰にとっても効果的

分析とは,ドメインの仕組みを理解し,それを適切な語彙(ユビキタス言語)で表現すること.

DDDの分析が効果を得やすいのは長期的なプロジェクト.見返りが期待出来なさそうなら,境界づけられたコンテキストごとに別のサポートアーキテクチャを選択する.

- ドメインモデルは永続化に関知しない

ドメインモデルに永続化レイヤーへのアクセスを要求するメソッドを与えるべきではない.

理想はまったくインフラレイヤーに依存しないドメインモデルだが,フレームワーク制約を受けることはままあるので,依存関係を最低限にしたドメインモデルの構築が現実的な目標になりうる.

- ドメイン層の内側

ドメイン層の大雑把な構成は,

- ドメインモデル(エンティティ,値オブジェクト)
- ドメインサービス(ここでいうサービスはビジネスロジックのことで,SOAのサービスやWebサービスのそれとは異なる)
- モジュール

エンティティの代わりに永続化を担うのがリポジトリ.

△リポジトリがエンティティの永続化を担う
○リポジトリがエンティティのサブセットである集約の永続化を担う

- 集約

ドメインモデルを扱っていると常に同時に使用/参照されるエンティティの存在に気づく.

集約が担うのは,モデル内のエンティティをまとめたり区切ったりする整合性の境界を決めること.
整合性はたいていトランザクションに紐づく.

集約はビジネスの整合性を担保するための手段.
集約はドメインモデルの不変条件を持つ.

ルートエンティティは集約に含まれるエンティティをカプセル化し,それらのプロキシとして機能する.

うまく設計された集約では１トランザクションにつき1つの集約が変更される.

子エンティティにパブリックコンストラクタを設けると集約の整合性が失われる可能性があるため避けたい方が良い.

集約のメリットは,モデルが複数の別のモデルと関連付けられて複雑なリレーションになるのを防ぎやすい考え方であるという点.

集約におけるルール

  - ルートエンティティが参照できるのは同じ集約内のエンティティか別の集約のルートエンティティのみ.
    - 集約内のエンティティにはライフサイクルや同一性があるので集約の外から直接参照できない.(ルートエンティティ経由で参照する)
  - 子エンティティは別のルートエンティティへの参照を保持できる.

集約における不変条件の例

商品発送後は注文情報を更新できないというビジネス・ルールが要求される場合には,集約ルートは注文情報をコードから更新できないようにしなければならない.

集約にカプセル化されているオブジェクトの永続化の責務はすべて集約にある.

データベース開発者に対しての集約のイメージ

  - 集約: 外部キー関係でリンクされたテーブルの和集合
  - 集約ルート: 外部キー関係のグラフにおいて,外向きの外部キー参照のみを含んでいる一意なテーブル

- ドメインサービス

ドメインロジックを実装するクラスで,特定の集約に属さない.

ビジネスアクションを実装する目的で,集約やリポジトリのアクティビティを調整する.
メールやテキスト送信が必要な場合はインフラレイヤのサービスを使用することもある.

ドメインサービスの使用を検討するのは,ビジネスロジックがどの集約にも適合せず,処理に合わせて既存の集約設計を見直すことが不可能な場合.いわゆる最後の砦.

ドメインサービスが実装するアクションは要件にもとづいている必要がある.
ドメインサービスで使用される名前はユビキタス言語である必要がある.
アプリケーションサービスから呼び出されるアクションを定義する.

ドメインサービスの例

ゴールドカスタマーは以下の条件を満たす顧客を言う.

  - 指定された範囲の商品をしきい値を超えて発注した場合

これを判定するためには,データベースアクセスが必要になる.なのでエンティティはデータベースアクセスに無関心であるという制約のもと実装するためには顧客エンティティがIsGoldのようなメソッドを持つのは制約違反になる.
なのでドメインサービスとして定義するのが良い.

- リポジトリ

ルートエンティティごとに1つのリポジトリを持つ.

インターフェースはドメインレイヤに,実装はインフラレイヤに持つ.DIPを使うことが多い.
実装ではORMやデータベース・アクセスのライブラリ・フレームワークを使用する.

- ドメインイベント

ドエインイベントを利用するメリットは,イベントを作成するコードに触れず,ハンドラー側にイベントごとの振る舞いを追加できる,複数の場所でイベントを発生させることができるようになるという点.

余談として,私の経験ではドメインイベントを利用した方が実装には拡張性があると考えたが,ビジネス側からブラウザクッキーと結びつけが顧客登録時に欲しい,メールの開封率はとても低いのでその場でトラッキングIDが確定するとMAを運用する上で価値が出しやすいという要件をもらったのでシーケンシャルな実装をせざるを得なかったということがあった.

- 横断的関心事

インフラストラクチャ層は横断的関心事に対処する場所でもある.

  - セキュリティAPI(認証/承認)
  - ログ
  - トレース

- 検証

ドメインモデル,ドメインサービスで適切な粒度で不変条件,整合性チェックを行う.

- セキュリティ

承認の側面を考える.

アプリケーション層では,許可された呼び出しでのみがドメインロジックにアクセスできるように制御すべき.

セキュリティの粒度とユースケースが一致する場合は,プレゼンテーション層の入り口で承認を行うこともある.

- ログ

ドメインモデルからログを出力することがビジネス上きわめて重要と判断される場合はDIPなどを使ってインフラレイヤーの実装を使ってログ出力する.

- キャッシュ

読取りのパフォーマンスを担保するためにキャッシュを利用することがある.
実装はインフラレイヤーに隠す.

私の聞いた話では,広告界隈ではレスポンス速度がビジネス上きわめて重要なので集約単位でキャッシュしたという事例がある.

---

## 第9章 ドメインモデルの実装

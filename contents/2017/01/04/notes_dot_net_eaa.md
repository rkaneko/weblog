.NET EAAを読んで考えたこと
===

# 第3部 サポートアーキテクチャ

## 第8章 ドメインモデルの紹介

- すべては振る舞いのために

ドメインモデルの目的は,アプリケーションで扱われる基本的なビジネスコンセプトをできるだけ忠実に表現することにある.

ドメインモデルに課される制約の目的は,クラスを基本的なビジネスコンセプトと完全に一致させ,常に整合性を確保することにある.

このために,データよりも振る舞いに重点を置いた設計にする必要がある.

- DDDはいつでも誰にとっても効果的

分析とは,ドメインの仕組みを理解し,それを適切な語彙(ユビキタス言語)で表現すること.

DDDの分析が効果を得やすいのは長期的なプロジェクト.見返りが期待出来なさそうなら,境界づけられたコンテキストごとに別のサポートアーキテクチャを選択する.

- ドメインモデルは永続化に関知しない

ドメインモデルに永続化レイヤーへのアクセスを要求するメソッドを与えるべきではない.

理想はまったくインフラレイヤーに依存しないドメインモデルだが,フレームワーク制約を受けることはままあるので,依存関係を最低限にしたドメインモデルの構築が現実的な目標になりうる.

- ドメイン層の内側

ドメイン層の大雑把な構成は,

- ドメインモデル(エンティティ,値オブジェクト)
- ドメインサービス(ここでいうサービスはビジネスロジックのことで,SOAのサービスやWebサービスのそれとは異なる)
- モジュール

エンティティの代わりに永続化を担うのがリポジトリ.

△リポジトリがエンティティの永続化を担う
○リポジトリがエンティティのサブセットである集約の永続化を担う

- 集約

ドメインモデルを扱っていると常に同時に使用/参照されるエンティティの存在に気づく.

集約が担うのは,モデル内のエンティティをまとめたり区切ったりする整合性の境界を決めること.
整合性はたいていトランザクションに紐づく.

集約はビジネスの整合性を担保するための手段.
集約はドメインモデルの不変条件を持つ.

ルートエンティティは集約に含まれるエンティティをカプセル化し,それらのプロキシとして機能する.

うまく設計された集約では１トランザクションにつき1つの集約が変更される.

子エンティティにパブリックコンストラクタを設けると集約の整合性が失われる可能性があるため避けたい方が良い.

集約のメリットは,モデルが複数の別のモデルと関連付けられて複雑なリレーションになるのを防ぎやすい考え方であるという点.

集約におけるルール

  - ルートエンティティが参照できるのは同じ集約内のエンティティか別の集約のルートエンティティのみ.
    - 集約内のエンティティにはライフサイクルや同一性があるので集約の外から直接参照できない.(ルートエンティティ経由で参照する)
  - 子エンティティは別のルートエンティティへの参照を保持できる.

集約における不変条件の例

商品発送後は注文情報を更新できないというビジネス・ルールが要求される場合には,集約ルートは注文情報をコードから更新できないようにしなければならない.

集約にカプセル化されているオブジェクトの永続化の責務はすべて集約にある.

データベース開発者に対しての集約のイメージ

  - 集約: 外部キー関係でリンクされたテーブルの和集合
  - 集約ルート: 外部キー関係のグラフにおいて,外向きの外部キー参照のみを含んでいる一意なテーブル

- ドメインサービス

ドメインロジックを実装するクラスで,特定の集約に属さない.

ビジネスアクションを実装する目的で,集約やリポジトリのアクティビティを調整する.
メールやテキスト送信が必要な場合はインフラレイヤのサービスを使用することもある.

ドメインサービスの使用を検討するのは,ビジネスロジックがどの集約にも適合せず,処理に合わせて既存の集約設計を見直すことが不可能な場合.いわゆる最後の砦.

ドメインサービスが実装するアクションは要件にもとづいている必要がある.
ドメインサービスで使用される名前はユビキタス言語である必要がある.
アプリケーションサービスから呼び出されるアクションを定義する.

ドメインサービスの例

ゴールドカスタマーは以下の条件を満たす顧客を言う.

  - 指定された範囲の商品をしきい値を超えて発注した場合

これを判定するためには,データベースアクセスが必要になる.なのでエンティティはデータベースアクセスに無関心であるという制約のもと実装するためには顧客エンティティがIsGoldのようなメソッドを持つのは制約違反になる.
なのでドメインサービスとして定義するのが良い.

- リポジトリ

ルートエンティティごとに1つのリポジトリを持つ.

インターフェースはドメインレイヤに,実装はインフラレイヤに持つ.DIPを使うことが多い.
実装ではORMやデータベース・アクセスのライブラリ・フレームワークを使用する.

- ドメインイベント

ドエインイベントを利用するメリットは,イベントを作成するコードに触れず,ハンドラー側にイベントごとの振る舞いを追加できる,複数の場所でイベントを発生させることができるようになるという点.

余談として,私の経験ではドメインイベントを利用した方が実装には拡張性があると考えたが,ビジネス側からブラウザクッキーと結びつけが顧客登録時に欲しい,メールの開封率はとても低いのでその場でトラッキングIDが確定するとMAを運用する上で価値が出しやすいという要件をもらったのでシーケンシャルな実装をせざるを得なかったということがあった.

- 横断的関心事

インフラストラクチャ層は横断的関心事に対処する場所でもある.

  - セキュリティAPI(認証/承認)
  - ログ
  - トレース

- 検証

ドメインモデル,ドメインサービスで適切な粒度で不変条件,整合性チェックを行う.

- セキュリティ

承認の側面を考える.

アプリケーション層では,許可された呼び出しでのみがドメインロジックにアクセスできるように制御すべき.

セキュリティの粒度とユースケースが一致する場合は,プレゼンテーション層の入り口で承認を行うこともある.

- ログ

ドメインモデルからログを出力することがビジネス上きわめて重要と判断される場合はDIPなどを使ってインフラレイヤーの実装を使ってログ出力する.

- キャッシュ

読取りのパフォーマンスを担保するためにキャッシュを利用することがある.
実装はインフラレイヤーに隠す.

私の聞いた話では,広告界隈ではレスポンス速度がビジネス上きわめて重要なので集約単位でキャッシュしたという事例がある.

---

## 第9章 ドメインモデルの実装

I-By-Stuffとしてオンラインストアの例を取り上げてドメインモデルの設計実装例を説明している章.

- ビジネスロジックの場所
  - メソッドのコードがエンティティのメンバのみを扱う場合は,おそらくエンティティに属する.
  - メソッドのコードが同じ集約内の他のエンティティまたは値オブジェクトにアクセスする必要がある場合は,おそらく集約ルートに属する.
  - メソッドのコードが永続化レイヤに対する問い合わせや更新を必要とする場合,またはエンティティの境界の外側にある参照を取得する必要がある場合,ドメインサービスメソッドに属する.

- DDDのエンティティの特徴

  - 同一性が明確に定義されている.
  - 振る舞いを持つ(public/非public).
  - 状態が読み取り専用のプロパティによって表現される.
  - プリミティブ型の使用は限定的で値オブジェクトと置き換えられる.
  - 複数のコンストラクタよりもファクトリメソッドが優先される.

- エンティティの同一性

  - IDやその他の組み合わせ(名前と番号のような)で表現される.
  - エンティティの同一性は同一性プロパティによって定義され,判定される.

- 値オブジェクト

  - エンティティとは異なり可変の状態を持たない.
  - データによって識別されるため同一性を必要としない.(プロパティがすべて同じなら同じ値とみなす.)
  - コンストラクタのみで値を受け取る.
  - public getterを通じて値を提供.
  - Immutable.
  - hash/equalsメソッドを実装.
  - プリミティブ型と置き換えて使用されることがしばしば.

-　集約の設計

  - コンストラクタではなく,ファクトリメソッドとしてインスタンス生成方法を提供することで,データにおける制約を定義したり,ユビキタス言語に沿った実装ができる.
  - 集約内にコレクションを定義する場合はCQRSにおけるメリットも検討する?
    - コレクションにおける書き込み・読み込みを同時に扱うことは複雑性が増しやすい.

- ビューモデル

  - ビューモデルは純粋なデータコンテナーであり,ドメインエンティティやDTO形式で表される.
  - JSのreduxのstateはSerializableであることが求められることがしばしばで,この制約の元ではstateに振る舞いをもつObjectをもたせるのは厳しくなるので,データコンテナーとしてのViewModelと捉えるように求められていると考える.
    - 本書ではViewModelがドメインエンティティをラッピングすることも紹介されているが,reduxにおいてはドメインモデルからViewModelを生成することになりそう.

- ドメインイベント

例えばオンラインストアで注文が作成されると,顧客のポイントカードにポイントを追加するといったことを行う場合,シーエンシャルに注文作成後の処理として実装することもできる.

しかしながら,ビジネス上ポイント付与処理が頻繁に変更されるような要件のものであれば,シーケンシャルに処理するよりもイベントとハンドラによって疎結合に実装したほうが,テスタビリティがよくなったりや複雑度が抑えられる可能性がある.また別のイベントハンドラを定義することにより別の処理を行う拡張もしやすくなる.

---
